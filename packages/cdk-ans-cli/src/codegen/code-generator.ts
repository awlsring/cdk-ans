import { CodeMaker } from 'codemaker';
import { Language } from '../import/importer';

export interface GenerateOptions {
  readonly classNamePrefix?: string;
}

export abstract class CodeGenerator {
  readonly name: string;
  readonly filename: string;
  readonly targetLanguage: Language;
  readonly prefix?: string;
  readonly constructName: string;

  constructor(name: string, targetLanguage: Language, prefix?: string) {
    this.name = name;
    this.targetLanguage = targetLanguage;
    this.filename = this.determineFilename(name, targetLanguage);
    this.prefix = prefix;
    this.constructName = this.toPascalCase(this.name);
  }

  protected abstract writeModuleImports(code: CodeMaker): void;

  protected abstract writeConstructProps(code: CodeMaker, options: GenerateOptions): void;

  protected abstract writeConstruct(code: CodeMaker, options: GenerateOptions): void;

  protected writeDocumentationHeader(code: CodeMaker, description: string[]) {
    code.line('/**');
    for (const line of description) {
      code.line(` * ${line}`);
    }
    code.line(' */');
  }

  private writeImports(code: CodeMaker) {
    code.line('// Generated by cdk-ans');
    code.line('');
  }

  protected determineFilename(name: string, language: Language): string {
    let newName = name;
    switch (language) {
      case Language.PYTHON:
      case Language.JAVA:
        newName = name.split('.').reverse().join('.');
        break;
    }
    return newName;
  }

  private toPascalCase(str: string): string {
    return str.replace(/(\w)(\w*)/g, (_, g1, g2) => g1.toUpperCase() + g2.toLowerCase());
  }

  async generate(code: CodeMaker, options: GenerateOptions): Promise<void> {
    this.writeImports(code);
    this.writeModuleImports(code);
    this.writeConstructProps(code, options);
    this.writeConstruct(code, options);
  }
}